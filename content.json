{"meta":{"title":"草丛里的知识","subtitle":null,"description":null,"author":"goodliang","url":"http:www.shoukailiang.cn"},"pages":[{"title":"about","date":"2018-02-18","updated":"2018-02-18","comments":true,"path":"about/index.html","permalink":"http:www.shoukailiang.cn/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-18","updated":"2018-02-18","comments":false,"path":"categories/index.html","permalink":"http:www.shoukailiang.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-18","updated":"2018-02-18","comments":false,"path":"tags/index.html","permalink":"http:www.shoukailiang.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"快速学会git","slug":"快速学会git","date":"2018-03-20","updated":"2018-03-20","comments":true,"path":"2018/03/20/快速学会git/","link":"","permalink":"http:www.shoukailiang.cn/2018/03/20/快速学会git/","excerpt":"","text":"克隆项目：git clone https://github.com/shoukailiang/test.git 设置 如果你不设置可能还push不上去，第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录： git config –global user.name “shoukailiang” git config –global user.email “shoukailiang@qq.com“ git status 查看状态 [master ≡ +2 ~0 -0!]（红色代表是工作区）：工作区有两个添加的文件，0个修改，0个删除 [master ≡ +1 ~0 -0（绿色） | +1 ~0 -0 !（红色）]：绿色表示暂存区 ！表示有冲突 git add 添加到暂存区 git commit 提交到版本库，会弹出一个文件填注释 git add .把修改过得文件全部提交到暂存区（后面是.） git commit -m “change demo01”:注释写在引号里面，不会弹出记事本 git commit -a -m “drag.js”：先添加到暂存区后添加到版本库的简写，引号里面写注释 git log：查看提交的历史，历史多了之后要按回车来显示，退出按q git diff :工作区和暂存区的文件的差异的对比 git diff –cached：暂存区与版本库之间的对比（或者git diff –staged） git diff master:工作区与版本库之间的差异 ，master那个是分支的名字 撤销 git reset HEAD drag.js 从暂存区撤销回工作区 git checkout – drag.js 从版本库撤销回工作区（会先从暂存区撤销，如果没有才会到版本库中撤销） git commit -m “change3 drag.js and demo01.html” –amend ：比如有两个文件1,2 我把1 add到暂存区，然后commit了全部，这时候就除了错误，可以使用上述代码：就达到了撤销上一次的commit 然后把文件全部commit ；使用git log 并不会有那次commit的注释信息 删除： git rm test.txt ：把暂存区中的test.txt删除（要先把工作区中的这个文件删除，否侧会报错） git rm -f test.txt 会把暂存区和工作区的test.txt删掉（要先把test.txt add 到暂存区） git rm –cached test.txt 把暂存区的test.txt删掉，不会吧工作区的test.txt删掉 恢复： 指定文件：比如一不小心在工作区把一个文件给误删了，这时候git log 后找到commit 的id 然后 git checkout e154cb8c45eb drag.js git reset –hard e154cb8c45eb 恢复版本，不管有多少文件，可以去过去也可以去未来（未来至回退之后的未来） git reset –hard HEAD^ 回到上一个版本 git reset –hard HEAD~2 回退两个版本（跳过两个，回退到第三个） git reflog：把历史版本全都打印出来 git remote 查看远程仓库的名字 git remote -v 查看名字所对应的远程仓库的地址 git push origin master （origin是远程仓库的名字 master是分支名） 解决冲突： git fetch 拉取远端仓库代码但不进行合并，需要手动合并（在工作区内并不会直接合并还是原来的代码，可以先查看区别后再合并） 查看区别 git diff master origin/master 合并: git merge origin/master,合并会把两个都合并，让我们自己选择（多余的删除） git pull 拉取远端仓库代码直接合并 开源项目协作（没权限）： fork:相当于一个镜像放在自己的仓库，克隆在本地，修改代码，（也可以在github上直接修改）发布到自己的仓库，然后pull request ,写一些留言，对方会看到，对方可以选择 合并 分支： git branch 查看分支 git branch new1 创建new1的新分支 git checkout new1 切换到new1的分支 git checkout -b new2 创建new2分支并且切换到new2分支上 （先切换到master分支上）， git merge new1 将new1与master合并 git branch –merged ：可以知道当前分支下有被合并的分支 ，比如master分支下合并了new1 git branch –no-merged 当前分支下没有被合并的分支 git branch -d new1 new1和branch合并后，把new1删除，只能删掉被合并的分支，比如new2没有和master合并就不能删除new2 git branch -D new2 强制把没有合并的分支删掉 有冲突的合并（两个分支不同） 在master上git merge new1 会让你自己选择留下哪个然后 git commit -a -m “…..” git push origin new1 把new1分支提交到远端仓库上 git tag 查看标签 git tag v1.0 v1.0版之后：git push origin v1.0 （这里v1.0不是分支） git reset HEAD~ 撤销回上一次提交的，和之前在暂存区里提交前一样的状态 推荐git 教程 廖雪峰git，非常的好 git小书","categories":[{"name":"工具","slug":"工具","permalink":"http:www.shoukailiang.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http:www.shoukailiang.cn/tags/工具/"},{"name":"命令行","slug":"命令行","permalink":"http:www.shoukailiang.cn/tags/命令行/"},{"name":"git","slug":"git","permalink":"http:www.shoukailiang.cn/tags/git/"}]},{"title":"es6，es7的一些语法（笔记）","slug":"es6，es7的一些语法（笔记）","date":"2018-03-15","updated":"2018-03-19","comments":true,"path":"2018/03/15/es6，es7的一些语法（笔记）/","link":"","permalink":"http:www.shoukailiang.cn/2018/03/15/es6，es7的一些语法（笔记）/","excerpt":"","text":"const1234567const a=3; //定义常量// 如果要用es 5的方式怎么写呢？？Object.defineProperty(window, &quot;a&quot;, &#123; value: 37, writable: false,&#125;);console.log(window.a) 作用域es6的作用域123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 在es5中,并没有块级作用域，先用es5写一个作用域看看 123456789101112var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10a[5](); // 10a[4](); // 10a[3](); // 10a[2](); // 10a[1](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 ES6 定义属性es5怎么写呢123456var x = 1, y = 2;var object = &#123; x: x, y: y&#125;;console.log(object.x); //output &quot;1&quot; 在es6中12345678//给一个属性赋一个变量值，如果变量名和属性名相同，ES6 提供了一个简洁的语法，可以省略变量名let x = 1, y = 2;let object = &#123; x, y &#125;;console.log(object.x); //output &quot;1&quot; 箭头函数1234567891011121314151617181920212223242526// es5中的thisvar A = function () &#123; this.a = &apos;a&apos;; this.b = &apos;b&apos;; this.c = &#123; a: &apos;a++&apos;, b: function () &#123; console.log(this.a); &#125; &#125;&#125;console.log(new A().c.b()) // a++ 因为es5中的this即谁调用它，this就指向谁//es6var A = function () &#123; this.a = &apos;a&apos;; this.b = &apos;b&apos;; this.c = &#123; a: &apos;a++&apos;, b: ()=&gt;&#123; console.log(this.a); &#125; &#125;&#125;console.log(new A().c.b()) // a,箭头函数this的指向是定义时this的指向，b函数在定义的时候this就指向函数体里面的this 123456//带有默认参数的箭头函数let hello =(name=&apos;world&apos;)=&gt;&#123; console.log(`hello $&#123;name&#125;`) //注意这边不是单引号&#125;hello() //hello worldhello(&apos;skl&apos;)//hello skl 1234//多个参数let cal1 =(num1,num2)=&gt;num1*num2let arr=[6,7]console.log(cal1(...arr))//展开 12345678function hello(name1,name2)&#123; console.log(name1,name2)&#125;let arr =[&apos;skl1&apos;,&apos;skl2&apos;];//es5//hello.apply(null,arr)//es6hello(...arr) 默认参数123456789// es5function a(x,y ) &#123; x=x||1; y=y||2;&#125;// es6function b(x=1,y=2)&#123; return x+y;&#125; 可变参数12345678910111213141516171819202122232425262728293031323334353637&#123; //es5 function f() &#123; var a = Array.prototype.slice.call(arguments); var sum = 0; a.forEach(function (item) &#123; sum += item; &#125;) return sum; &#125; console.log(f(1, 2, 3, 4)) &#125;&#123; //es5 function f(...a) &#123; var sum = 0; a.forEach(function (item) &#123; sum += item; &#125;) return sum; &#125; console.log(f(1, 2, 3, 4)) &#125;// 扩展运算符的使用// 合并数组 es5&#123; var a=[1,2,4]; var b=[11,111,111]; var c=b.concat(a); console.log(c)&#125;// 合并数组 es6运用扩展运算符&#123; var a=[1,2,4]; var b=[11,111,111]; var c=[...a,...b]; console.log(c)&#125; 对象扩展1234567var obj=&#123; name:&apos;skl&apos;, age:18,&#125;console.log(Object.keys(obj))//[&quot;name&quot;,&quot;age&quot;]console.log(Object.values(obj))//[&quot;skl&quot;,18]console.log(Object.entries(obj))// key 和value变成一个数组 123456789const name = &apos;skl&apos;const age=&apos;nian&apos;;const height=&apos;shengao&apos;const obj = &#123; [age]:18, height&#125;obj[name] = &apos;hello skl&apos;;console.log(obj)//&#123;nian: 18, height: &quot;shengao&quot;, skl: &quot;hello skl&quot;&#125; 123const obj1=&#123;name:&apos;skl&apos;,age:18&#125;const obj2=&#123;type:&apos;ha&apos;,aa:90&#125;console.log(&#123;...obj1,...obj2&#125;)//&#123;name: &quot;skl&quot;, age: 18, type: &quot;ha&quot;, aa: 90&#125; 12345678//结构赋值const arr =[&apos;skl&apos;,&apos;sk2&apos;];let [arg1,arg2]=arr;console.log(arg1,arg2)//skl sk2const obj=&#123;nian: 18, height: &quot;shengao&quot;, skl: &quot;hello skl&quot;&#125;const &#123;nian,height&#125;=obj;console.log(nian,height)//18 shengao 代理做数据保护es5中的数据保护123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; // 数据保护（相当于私有变量）es5的写法,定义一个构造函数 var Person = function () &#123; var data = &#123; name: &apos;es5&apos;, sex: &apos;male&apos;, age: 20 &#125; // getter 和setter this.get = function (key) &#123; return data[key] &#125; this.set = function (key, value) &#123; if (key !== &apos;sex&apos;) &#123; data[key] = value; &#125; &#125; &#125; // 声明实例 var person = new Person(); // 读取 console.table(&#123; name: person.get(&apos;name&apos;), sex: person.get(&apos;sex&apos;), aeg: person.get(&apos;ageqe3w&apos;) &#125;) // 修改 person.set(&apos;name&apos;, &apos;啦啦啦&apos;);// 这时候console的结果就会变了 person.set(&apos;sex&apos;, &apos;male&apos;)// console出来发现没有用因为数据被保护了&#125;&#123; // 另一种写法 var Person = &#123; name: &apos;skl&apos;, age: 10, &#125; // sex只可读不可写 Object.defineProperties(Person, &apos;sex&apos;, &#123; writeable: false, value: &apos;male&apos;, &#125;) console.table(&#123; name: Person.name, age: Person.age, sex: Person.sex, &#125;) // 若强行给只读属性复制会报错&#125; es6中通过代理的方式做数据保护12345678910111213141516171819&#123; // es的代理 let Person = &#123; name: &apos;11&apos;, age: 11, sex: &apos;male&apos; &#125; //person是暴露给用户的，吧上面的Person保护起来 let person = new Proxy(Person, &#123; get(target, key) &#123; return target[key] &#125;, set(target, key, value) &#123; if (key !== &apos;sex&apos;) &#123; target[key] = value; &#125; &#125; &#125;)&#125; 字符串拼接在es5中，凭借字符串要不断的+,尤其是在html模板的时候，变得特别不方便1234const a=3;console.log(`skl$&#123;a&#125;`)//skl3`Hello $&#123;&apos;World&apos;&#125;`// &quot;Hello World&quot; for… of…12345678910var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();console.log(iterator) //Array Iterator &#123;&#125;for (let e of iterator) &#123; //返回有下标的数组 console.log(e) //[0, &quot;a&quot;] //[1, &quot;b&quot;] //[2, &quot;c&quot;]&#125; 1234567var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr;for (let e of iterator) &#123; console.log(e); //a b c&#125; 123456789var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();for (let [index,e] of iterator) &#123; console.log(index,e); // 0 &quot;a&quot; // 1 &quot;b&quot; // 2 &quot;c&quot;&#125; 123456789var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();for (let [index,e] of iterator) &#123; console.log(e);&#125;// a // b// c promise123456789101112131415161718192021222324252627282930313233343536373839let state = 1;function step1(resolve, reject) &#123; console.log(&apos;1.开始-做饭&apos;); if (state == 1) &#123; resolve(&apos;做饭--完成&apos;); &#125; else &#123; reject(&apos;做饭--出错&apos;); &#125;&#125;function step2(resolve, reject) &#123; console.log(&apos;2.开始-吃饭&apos;); if (state == 1) &#123; resolve(&apos;吃饭--完成&apos;); &#125; else &#123; reject(&apos;吃饭--出错&apos;); &#125;&#125;function step3(resolve, reject) &#123; console.log(&apos;3.开始-收拾&apos;); if (state == 1) &#123; resolve(&apos;收拾--完成&apos;); &#125; else &#123; reject(&apos;收拾--出错&apos;); &#125;&#125;new Promise(step1) .then(function (val) &#123; console.log(val) return new Promise(step2) &#125;) .then(function (val) &#123; console.log(val) return new Promise(step3) &#125;).then(function (val) &#123; console.log(val) &#125;) async12345async function testAsync()&#123; return &apos;hello async&apos;&#125;const result =testAsync();console.log(result); // 返回的是一个promise 123456789101112131415function getSomething()&#123; return &apos;something&apos;&#125;async function testAsync()&#123; return &apos;hello async&apos;&#125;async function test()&#123; const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1,v2)&#125;test() 模拟异步请求12345678910111213function takeLongTime()&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; resolve(&quot;long_time_value&quot;) &#125;,1000) &#125;)&#125;async function test()&#123; const v = await takeLongTime() console.log(v)&#125;test()","categories":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/tags/前端/"},{"name":"js","slug":"js","permalink":"http:www.shoukailiang.cn/tags/js/"},{"name":"es6","slug":"es6","permalink":"http:www.shoukailiang.cn/tags/es6/"},{"name":"es7","slug":"es7","permalink":"http:www.shoukailiang.cn/tags/es7/"}]},{"title":"js作用域（变量提升，预解析）","slug":"js作用域（变量提升，预解析）","date":"2018-03-10","updated":"2018-03-10","comments":true,"path":"2018/03/10/js作用域（变量提升，预解析）/","link":"","permalink":"http:www.shoukailiang.cn/2018/03/10/js作用域（变量提升，预解析）/","excerpt":"","text":"典型例题如下：1234567891011&lt;script&gt; alert(a) // function a() //10 var a=3; function a() &#123; alert(10) &#125; alert(a) //3 a=6; a() // 没有a这个函数了啊&lt;/script&gt; 为什么会有这样的结果呢？请看下面的例题 例题一123456789101112131415161718192021222324252627&lt;script&gt; /*1 alert(a); //underfined（未定义） var a=1; */ /*2 alert(a) a=1; //报错,a is not defined */ /* js解析器 1.“找一些东西”（js预解析）var function 参数 根据var找到； a=未定义，所有的变量在正式运行前都提前都赋值了未定义 fn1=function fn1() &#123;alert(2)&#125; 所有的函数，在正式运行代码之前，都是整个函数快 2.逐行解读代码 表达式：= + - * 、/ % ++ --! 参数 ....... alert(a) var a=1; function fn1() &#123;alert(2)&#125; */&lt;/script&gt; 例题二1234567891011121314151617181920212223&lt;script&gt; /* js预解析只会留下一个，！！！变量和函数重名了，只留下函数 第一步： a=未定义 a=function a() &#123;alert(2)&#125;，那么上面的那个就被干掉了； 最后，在预解析仓库里面只有： a=function a() &#123;alert(4)&#125; */ //开始逐行解读 alert(a);//function a() &#123;alert(4)&#125; var a=1;//表达式：a就被改成1了; alert(a)//1 function a() &#123;alert(2)&#125;//是函数声明，不是表达式，不会改变a的值 alert(a);//1 var a=3; alert(a);//3 function a() &#123;alert(4)&#125;; alert(a);//3 a()//报错，读完代码之后，js仓库里面只有a=3;&lt;/script&gt; 例题三12345678910111213141516171819202122232425262728293031&lt;!--&lt;script&gt;--&gt; &lt;!--//1.预解析--&gt; &lt;!--//2.执行--&gt;&lt;!--&lt;/script&gt;--&gt;&lt;!--&lt;script&gt;--&gt; &lt;!--//3.预解析--&gt; &lt;!--//4.执行--&gt;&lt;!--&lt;/script&gt;--&gt; &lt;!-- 1. &lt;script&gt; var a=3; &lt;/script&gt; &lt;script&gt; alert(a);//3 &lt;/script&gt; --&gt; &lt;!-- 2. &lt;script&gt; alert(a);//报错；a is not defined &lt;/script&gt; &lt;script&gt; var a=3; &lt;/script&gt; --&gt; 例题四1234567891011121314151617181920212223&lt;script&gt; var a=1; function fn1() &#123; alert(a);//undefined var a=2; &#125; fn1(); alert(a);//1 /* 1.预解析 全局的 a=未定义 fn1=function fn1() &#123;alert(a);var a=2;&#125; 2.逐行解读代码: 表达式 a=1; 函数调用 1）预解析 局部的 a =未定义 2）逐行解读代码 alert(a)=&gt;未定义 a=2; */&lt;/script&gt; 例题4-1123456789101112131415161718192021222324&lt;script&gt; var a=1; function fn1() &#123; alert(a);//1 a=2; &#125; fn1(); alert(a);//2 /* 1.预解析 全局的 a=未定义 fn1=function fn1() &#123;alert(a); a=2;&#125; 2.逐行解读代码: 表达式 a=1; 函数调用 1）预解析 顺着这一层的作用域跳到上一层去找（作用域链） 2）逐行解读代码 alert(a)//当前作用域没有，顺着这一层的作用域跳到上一层去找（作用域链） a=2也是 先弹出1,再弹出2 */&lt;/script&gt; 例题4-212345678910111213141516171819202122&lt;script&gt; var a=1; function fn1(a) &#123;//参数相当于是一个局部变量 相当于括号里面是var a; alert(a);//undefined a=2; &#125; fn1(); alert(a);//1 /* 1.预解析 a=未定义 fn1=function fn1(a) &#123;alert(a); a=2;&#125; 2.逐行解读代码: 表达式 a=1; 函数调用 1）预解析 里面的a=未定义 2）逐行解读代码 里面的a=2; */&lt;/script&gt; 例题4-3123456789101112131415161718192021222324&lt;script&gt; var a=1;//标志1 function fn1(a) &#123;//参数相当于是一个局部变量 相当于括号里面是var a; alert(a);//1,这个a和标志1处的a是不相同的,这个a是局部的，外面的a是全局的 a=2; alert(a)//2 &#125; fn1(a);//这个a是全局 alert(a);//1 /* 1.预解析 a=未定义 fn1=function fn1(a) &#123;alert(a); a=2;&#125; 2.逐行解读代码: 表达式 a=1; 函数调用 1）预解析 里面的a=未定义 2）逐行解读代码 读到fn1(a)的时候 就function fn1(var a=1) 找到局部的a=2 */&lt;/script&gt; 例题4-41234567891011&lt;script&gt; var a=1; function fn1(a) &#123; //相当于var a;a=1(外面的) alert(a);//1 var a=2; console.log(a);//2 &#125; fn1(a); alert(a);//1&lt;/script&gt; 例题4-51234567891011&lt;script&gt; var a=1; function fn1(a) &#123; arguments[0]=3; alert(a);//3 var a=2; console.log(a);//2 &#125; fn1(a); alert(a);//1&lt;/script&gt; 例题5 想要获取函数内的值12345678910111213141516171819202122&lt;script&gt; //想要获取函数内的值 // 一 /* var str=&apos;&apos; function fn1() &#123; var a=&apos;1&apos;; str=a; &#125; fn1(); alert(str) */ // 二 function fn2() &#123; var a=&apos;100元&apos;; fn3(a); &#125; fn2() function fn3(b) &#123; alert(b) &#125;&lt;/script&gt; 例题61234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; /* 函数的大括号才是一个域 if条件判断的大括号不是一个作用域，var 写在大括号里面和外面是一样的 if(1)&#123; var a=1; &#125; alert(a); for 循环的&#123;&#125;也不是一个块级作用域 是作用域的标志是先解析后执行 */ /* alert(a);//undefined if(true)&#123; var a=1; &#125;*/ /* alert( fn1 );//underfine(最新的浏览器)，ie10及以下是可以弹出函数的。。。 if(true)&#123; var a=1; function fn1() &#123; alert(123) &#125; &#125;*/ /* //所以，以上代码要写成 alert( fn1 ); var a=1; function fn1() &#123; alert(123) &#125; if(true)&#123; &#125;*/&lt;/script&gt; 例题71234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;3&quot;&gt; &lt;script&gt; /* //1. window.onload=function () &#123; var oBtn=document.getElementsByTagName(&apos;input&apos;); for(var i=0;i&lt;oBtn.length;i++)&#123; oBtn[i].onclick=function () &#123; console.log(i);//3 &#125; &#125; &#125;*/ /* //2 window.onload=function () &#123; var oBtn=document.getElementsByTagName(&apos;input&apos;); for(var i=0;i&lt;oBtn.length;i++)&#123; oBtn[i].onclick=function () &#123; console.log(i);//undefined 因为函数域解析了,来自下面for的var i; for(var i=0;i&lt;oBtn.length;i++)&#123; oBtn[i].style.background=&apos;yellow&apos; &#125; &#125; &#125; &#125; */ &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/tags/前端/"},{"name":"js","slug":"js","permalink":"http:www.shoukailiang.cn/tags/js/"}]},{"title":"react生命周期笔记","slug":"react生命周期笔记","date":"2018-03-03","updated":"2018-03-03","comments":true,"path":"2018/03/03/react生命周期笔记/","link":"","permalink":"http:www.shoukailiang.cn/2018/03/03/react生命周期笔记/","excerpt":"","text":"组件的生命周期分成三个状态 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM Mounting(装载) getInitialState(): 在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。 componentWillMount()：服务器端和客户端都只调用一次，在初始化渲染执行之前立刻调用。不会触发再次渲染。 componentDidMount()：在初始化渲染执行之后立刻调用一次，仅客户端有效（服务器端不会调用）,可以设置state，会触发再次渲染，组件内部可以通过 Updating (更新) componentWillReceiveProps(nextProps) 在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。通常可以调用this.setState方法来比较this.props和nextProps的执行状态，完成对state的修改。在该函数中调用 this.setState() 将不会引起第二次渲染。 shouldComponentUpdate(nextProps,nextState): 在接收到新的 props 或者 state，将要渲染之前调用。该方法用来拦截新的props或state，然后判断是否更新组件 该方法在初始化渲染的时候不会调用，在使用 forceUpdate 方法的时候也不会。如果确定新的 props 和 state 不会导致组件更新，则此处应该 返回 false。 componentWillUpdate(nextProps, nextState)：在接收到新的 props 或者 state 之前立刻调用，即更新之前调用 在初始化渲染的时候该方法不会被调用。使用该方法做一些更新之前的准备工作。 注意：你不能在该方法中使用 this.setState()。如果需要更新 state 来响应某个 prop 的改变，请使用 componentWillReceiveProps。 componentDidUpdate(prevProps, prevState): 在组件的更新已经同步到 DOM 中之后立刻被调用。 该方法不会在初始化渲染的时候调用。使用该方法可以在组件更新之后操作 DOM 元素。 Unmounting(移除) componentWillUnmount：在组件从 DOM 中移除的时候立刻被调用。 在该方法中执行任何必要的清理,收尾工作，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。 参考文章: React-Native之React速学教程-(中)/) react生命周期","categories":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/categories/前端/"},{"name":"react","slug":"前端/react","permalink":"http:www.shoukailiang.cn/categories/前端/react/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/tags/前端/"},{"name":"js","slug":"js","permalink":"http:www.shoukailiang.cn/tags/js/"},{"name":"react","slug":"react","permalink":"http:www.shoukailiang.cn/tags/react/"},{"name":"生命周期","slug":"生命周期","permalink":"http:www.shoukailiang.cn/tags/生命周期/"},{"name":"框架","slug":"框架","permalink":"http:www.shoukailiang.cn/tags/框架/"}]},{"title":"styled-components","slug":"使用 styled-components","date":"2018-02-26","updated":"2018-03-03","comments":true,"path":"2018/02/26/使用 styled-components/","link":"","permalink":"http:www.shoukailiang.cn/2018/02/26/使用 styled-components/","excerpt":"","text":"styled-components 是一个常用的 css in js 类库。使得css代码也有了作用域。和所有同类型的类库一样，通过 js 赋能解决了原生 css 所不具备的能力，比如变量、循环、函数等。诸如 sass&amp;less 等预处理可以解决部分 css 的局限性，但还是要学习新的语法，而且需要对其编译，其复杂的 webpack 配置也总是让开发者抵触。而 styled-componens 很好的解决了这些问题，很适合 React 技术栈的项目开发。 安装和使用1npm install styled-components 123456789101112131415161718192021import React from &apos;react&apos;;import styled from &apos;styled-components&apos;class InfoNav extends React.Component &#123; render() &#123; const H1 = styled.h1` background-color: #a1a; text-align: center; &gt;span&#123; color:blue; &#125; `; return ( &lt;React.Fragment&gt; &lt;H1&gt; &lt;span&gt;信息完善页面&lt;/span&gt; &lt;/H1&gt; &lt;/React.Fragment&gt; ) &#125;&#125;export default InfoNav; 代码提示和高亮ide 貌似没能做到代码高亮和提示官网有vscode的插件1vscode-styled-components 组件样式继承12345678910111213141516171819202122import React from &apos;react&apos;;import styled from &apos;styled-components&apos;class InfoNav extends React.Component &#123; render() &#123; const H1 = styled.div` background-color: #a1a; text-align: center; font-size:20px; `; const SPAN = H1.extend` color: white; `; return ( &lt;React.Fragment&gt; &lt;H1&gt; &lt;SPAN&gt;&#123;this.props.name&#125;信息完善页面&lt;/SPAN&gt; &lt;/H1&gt; &lt;/React.Fragment&gt; ) &#125;&#125;export default InfoNav; 组件内部使用 className1234&lt;Wrapper&gt; &lt;h4&gt;Hello Word&lt;/h4&gt; &lt;div className=&quot;detail&quot;&gt;&lt;/div&gt;&lt;/Wrapper&gt; 对于这种 styled-components 和 className 混用，或者是一些伪类的情况同样是支持的：12345678910111213import styled from &apos;styled-components&apos;;const Wrapper = styled.div` display: block; h4 &#123; font-size: 14px; &amp;:hover &#123; color: #fff; &#125; &#125; .detail &#123; color: #ccc; &#125;`; 当然还可以通过 injectGlobal 的方式将通用的样式注入到全局中：1234567891011import styled, &#123; injectGlobal &#125; from &apos;styled-components&apos;;injectGlobal` @font-face &#123; font-family: &apos;Operator Mono&apos;; src: url(&apos;../fonts/Operator-Mono.ttf&apos;); &#125; body &#123; margin: 0; &#125;`; CSS 动画支持styled-components 同样对 css 动画中的 @keyframe 做了很好的支持。12345678910111213import &#123; keyframes &#125; from &apos;styled-components&apos;;const fadeIn = keyframes` 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;`;const FadeInButton = styled.button` animation: 1s $&#123;fadeIn&#125; ease-out;`; keyframes 方法会生成一个唯一的 key 作为 keyframes 的名称，保证它的作用域是在单个文件内，非全局的。 总结下面简单总结一下 styled-components 在开发中的表现： 提出了 container 和 components 的概念，移除了组件和样式之间的映射关系，符合关注度分离的模式； 可以在样式定义中直接引用到 js 变量，共享变量，非常便利； 支持组件之间继承，方便代码复用，提升可维护性； 兼容现有的 className 方式，升级无痛； 在实际应用中我们完全可以将 style 和 jsx 分开维护 原文链接：https://juejin.im/entry/59a57a2b5188252445327ac1 参考 ： https://www.jianshu.com/p/f188f7ea59b3","categories":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/categories/前端/"},{"name":"工具","slug":"前端/工具","permalink":"http:www.shoukailiang.cn/categories/前端/工具/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/tags/前端/"},{"name":"js","slug":"js","permalink":"http:www.shoukailiang.cn/tags/js/"},{"name":"react","slug":"react","permalink":"http:www.shoukailiang.cn/tags/react/"},{"name":"框架","slug":"框架","permalink":"http:www.shoukailiang.cn/tags/框架/"},{"name":"css","slug":"css","permalink":"http:www.shoukailiang.cn/tags/css/"}]},{"title":"从面相过程的拖拽到面向对象的拖拽再到简易的组件拖拽","slug":"从面相过程的拖拽到面向对象的拖拽再到简易的组件拖拽","date":"2018-02-21","updated":"2018-03-17","comments":true,"path":"2018/02/21/从面相过程的拖拽到面向对象的拖拽再到简易的组件拖拽/","link":"","permalink":"http:www.shoukailiang.cn/2018/02/21/从面相过程的拖拽到面向对象的拖拽再到简易的组件拖拽/","excerpt":"","text":"首先，是最基本的面向过程的拖拽代码12345678910111213141516171819202122232425262728293031323334353637383940/*css*/&lt;style&gt; #box&#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125;&lt;/style&gt;/*html*/&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;/*js*/&lt;script&gt;window.onload=function()&#123; var oDiv=document.getElementById(&apos;box&apos;); var disX=0; var disY=0; oDiv.onmousedown=function(event)&#123; //获取事件对象 var event=event||window.event; // disX相当于鼠标到div左侧的距离，同理disY disX=event.clientX-oDiv.offsetLeft; disY=event.clientY-oDiv.offsetTop; document.onmousemove=function(event)&#123; var event=event||window.event; oDiv.style.left=event.clientX-disX+&apos;px&apos;; oDiv.style.top=event.clientY-disY+&apos;px&apos;; &#125; document.onmouseup=function () &#123; // 鼠标释放时事件清空 document.onmousemove=null; document.onmouseup=null; &#125; return false; &#125;&#125;&lt;/script&gt; 开始改写版本一尽量不要出现函数嵌套函数 可以有全局变量 把onload中不是赋值的语句放在单独函数中123456789101112131415161718192021222324252627282930&lt;script&gt;var oDiv=null;var disX=0;var disY=0;window.onload=function()&#123; oDiv=document.getElementById(&apos;box&apos;); init()&#125;function init() &#123; oDiv.onmousedown=fnDown;&#125;function fnDown(event)&#123; var event=event||window.event; disX=event.clientX-oDiv.offsetLeft; disY=event.clientY-oDiv.offsetTop; document.onmousemove=fnMove; document.onmouseup=fnUp; return false;&#125;function fnMove(event)&#123; var event=event||window.event; oDiv.style.left=event.clientX-disX+&apos;px&apos;; oDiv.style.top=event.clientY-disY+&apos;px&apos;;&#125;function fnUp() &#123; document.onmousemove=null; document.onmouseup=null;&#125;&lt;/script&gt; 面向对象的改写 es5 全局变量就是属性 函数就是方法 onload中创建对象 改this指向问题 在ie和谷歌下，这样是可以的，但是火狐下，应为有些地方为了this指向 嵌套了一层函数，但火狐可不这样，他认为event是事件函数传递的，也就是事件后面更着的函数，这是好就需要把event当做参数传递了 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt;window.onload=function()&#123; var d=new Drag(&apos;box&apos;); d.init();&#125;//构造函数function Drag(id) &#123; this.disX=0; this.disY=0; this.oDiv=document.getElementById(id);&#125;Drag.prototype.init=function () &#123; // 这里的this 指向的是Drag这个类 var _this=this; this.oDiv.onmousedown=function () &#123; //这里嵌套一层是为了解决若写成this.fnDown的话，下面fnDown里面的this就会变成this.oDiv，相当于this就变成div了 // 匿名函数里的this是指window,因为this指的是调用他的对象，但是匿名函数不知道是谁调用的，所以可以认为是被window调用的 _this.fnDown() &#125;;&#125;Drag.prototype.fnDown=function (event) &#123; var event=event||window.event; this.disX=event.clientX-this.oDiv.offsetLeft; this.disY=event.clientY-this.oDiv.offsetTop; var _this=this; document.onmousemove=function () &#123; _this.fnMove() &#125;; document.onmouseup=this.fnUp; return false;&#125;Drag.prototype.fnMove=function (event) &#123; var event=event||window.event; this.oDiv.style.left=event.clientX- this.disX+&apos;px&apos;; this.oDiv.style.top=event.clientY- this.disY+&apos;px&apos;;&#125;Drag.prototype.fnUp=function () &#123; document.onmousemove=null; document.onmouseup=null;&#125;&lt;/script&gt; 但是火狐下报错:TypeError: event is undefined 火狐的解决办法12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt;window.onload = function () &#123; var d = new Drag(&apos;box&apos;); d.init();&#125;//构造函数function Drag(id) &#123; this.disX = 0; this.disY = 0; this.oDiv = document.getElementById(&apos;box&apos;);&#125;Drag.prototype.init = function () &#123; var _this = this; this.oDiv.onmousedown = function (event) &#123; //嵌套是为了解决this问题 var event = event || window.event; _this.fnDown(event) &#125;;&#125;Drag.prototype.fnDown = function (event) &#123; this.disX = event.clientX - this.oDiv.offsetLeft; this.disY = event.clientY - this.oDiv.offsetTop; var _this = this; document.onmousemove = function (event) &#123; _this.fnMove(event) &#125;; document.onmouseup = this.fnUp; return false;&#125;Drag.prototype.fnMove = function (event) &#123; this.oDiv.style.left = event.clientX - this.disX + &apos;px&apos;; this.oDiv.style.top = event.clientY - this.disY + &apos;px&apos;;&#125;Drag.prototype.fnUp = function () &#123; document.onmousemove = null; document.onmouseup = null;&#125;&lt;/script&gt; 也可以吧init 放进构造函数里面，这样只要new 一个就可以生成拖拽了 ,如下所示 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;window.onload=function()&#123; var d=new Drag(&apos;box&apos;);&#125;//构造函数function Drag(id) &#123; var _this=this; this.disX=0; this.disY=0; this.oDiv=document.getElementById(&apos;box&apos;); this.oDiv.onmousedown=function (event) &#123; //嵌套是为了解决this问题 var event=event||window.event; _this.fnDown(event) &#125;;&#125;Drag.prototype.fnDown=function (event) &#123; this.disX=event.clientX-this.oDiv.offsetLeft; this.disY=event.clientY-this.oDiv.offsetTop; var _this=this; document.onmousemove=function (event) &#123; _this.fnMove(event) &#125;; document.onmouseup=this.fnUp; return false;&#125;Drag.prototype.fnMove=function (event) &#123; this.oDiv.style.left=event.clientX- this.disX+&apos;px&apos;; this.oDiv.style.top=event.clientY- this.disY+&apos;px&apos;;&#125;Drag.prototype.fnUp=function () &#123; document.onmousemove=null; document.onmouseup=null;&#125;&lt;/script&gt; es6 面向对象的改写,也可以吧init 放进构造函数里面12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt;window.onload = function () &#123; var d = new Drag(&apos;box&apos;); d.init();&#125;// 类class Drag &#123; //构造函数 constructor(id) &#123; this.disX = 0; this.disY = 0; this.oDiv = document.getElementById(id); &#125; init() &#123; var _this = this; this.oDiv.onmousedown = function (event) &#123; var event = event || window.event; _this.fnDown(event) &#125;; &#125; fnDown(event) &#123; this.disX = event.clientX - this.oDiv.offsetLeft; this.disY = event.clientY - this.oDiv.offsetTop; var _this = this; document.onmousemove = function (event) &#123; _this.fnMove(event) &#125;; document.onmouseup = this.fnUp; return false; &#125; fnMove(event) &#123; this.oDiv.style.left = event.clientX - this.disX + &apos;px&apos;; this.oDiv.style.top = event.clientY - this.disY + &apos;px&apos;; &#125; fnUp() &#123; document.onmousemove = null; document.onmouseup = null; &#125;&#125;&lt;/script&gt; 初步总结 原则先写出普通的写法，然后改写成面向对象的写法 普通方法变形 尽量不要出现函数嵌套函数 可以有全局变量 把onload中不是赋值的语句放在单独函数中改写面向对象 全局变量就是属性 函数就是方法 onload中创建对象 改this指向问题 说了这么多，我们来封装一个拖拽组件吧组件就该可以自自定义样式吧～～～～～，data-config写入自定义的样式，有人说你怎么怎么鸡肋，不如css里面写写快，但也是可以不写的，有默认参数，js里面已经写好了，如果data-config写了的话是可以覆盖js里面的，具体看js代码1234567&lt;body&gt; &lt;div id=&quot;box1&quot; data-config=&apos;&#123;&quot;width&quot;: &quot;100px&quot;,&quot;height&quot;: &quot;100px&quot;,&quot;backgroundColor&quot;: &quot;black&quot;,&quot;position&quot;: &quot;absolute&quot;&#125;&apos;&gt;&lt;/div&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var div1 = new Drag(&apos;box1&apos;); div1.init(); &lt;/script&gt; 尽量让用户少写css,那你就帮他考虑周全吧12345678*&#123; padding: 0; margin: 0;&#125;div&#123; width: 200px; height: 200px;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 外层包裹防止函数被污染(function () &#123; // Drag 类 class Drag &#123; constructor (id) &#123; this.disX = 0; this.disY = 0; this.oDiv = document.getElementById(id); // 默认设置 this.config = &#123; &apos;width&apos;: &apos;200px&apos;, &apos;height&apos;: &apos;200px&apos;, &apos;backgroundColor&apos;: &apos;red&apos;, &apos;position&apos;: &apos;absolute&apos; &#125;; // 若有自定义属性，那就合并 if (this.getConfig()) &#123; Object.assign(this.config, this.getConfig()); &#125; console.log(this.config); this.init(); &#125; getConfig () &#123; var config = this.oDiv.getAttribute(&apos;data-config&apos;); if (config &amp;&amp; config !== &apos;&apos;) &#123; return JSON.parse(config); &#125; else &#123; return null; &#125; &#125; init () &#123; var _this = this; this.oDiv.onmousedown = function (ev) &#123; /* 传入_this,为了下面不在重复写 */ _this.fnDown(ev, _this); &#125;; // 改变设置的属性 for (const i in this.config) &#123; this.oDiv.style[i] = this.config[i]; &#125; &#125; /* 拖拽本体 */ fnDown (ev, _this) &#123; this.disX = ev.clientX - this.oDiv.offsetLeft; this.disY = ev.clientY - this.oDiv.offsetTop; document.onmousemove = function (ev) &#123; _this.fnMove(ev); &#125;; document.onmouseup = this.fnUp; /* 阻止默认事件 */ return false; &#125; fnMove (ev) &#123; this.oDiv.style.left = ev.clientX - this.disX + &apos;px&apos;; this.oDiv.style.top = ev.clientY - this.disY + &apos;px&apos;; &#125;; fnUp () &#123; document.onmousemove = null; document.onmouseup = null; &#125; &#125; window.Drag = Drag;&#125;)(); 你说啥？？不支持手机端？？那就来支持一下吧支持的不够怎么完美，见谅。。12345678910// 在fnDown里面先判断一下// 判断是否为手机端 var touch; if (ev.touches) &#123; touch = ev.touches[0]; &#125; else &#123; touch = ev; &#125; this.disX = touch.clientX - this.oDiv.offsetLeft; this.disY = touch.clientY - this.oDiv.offsetTop; pc上的web页面鼠 标会产生onmousedown、onmouseup、onmouseout、onmouseover、onmousemove的事件，但是在移动终端如 iphone、Touch、ipad,android上的web页面触屏时会产生ontouchstart、ontouchmove、ontouchend、ontouchcancel 事件，分别对应了触屏开始、拖拽及完成触屏事件和取消。当按下手指时，触发ontouchstart；当移动手指时，触发ontouchmove；当移走手指时，触发ontouchend。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 原理还是一样的// js代码如下(function () &#123; // Drag 类 class Drag &#123; constructor(id) &#123; this.disX = 0; this.disY = 0; this.oDiv = document.getElementById(id); // 默认设置 this.config = &#123; &apos;width&apos;: &apos;200px&apos;, &apos;height&apos;: &apos;200px&apos;, &apos;backgroundColor&apos;: &apos;red&apos;, &apos;position&apos;: &apos;absolute&apos; &#125;; // 若有自定义属性，那就合并 if (this.getConfig()) &#123; Object.assign(this.config, this.getConfig()); &#125; console.log(this.config); this.init(); &#125; getConfig() &#123; var config = this.oDiv.getAttribute(&apos;data-config&apos;); if (config &amp;&amp; config !== &apos;&apos;) &#123; return JSON.parse(config); &#125; else &#123; return null; &#125; &#125; init() &#123; var _this = this; // pc端 this.oDiv.onmousedown = function (ev) &#123; /* 传入_this,为了下面不在重复写 */ _this.fnDown(ev, _this); &#125;; // 移动端 this.oDiv.ontouchstart=function(ev)&#123; _this.fnDown(ev, _this); &#125; // 改变设置的属性 for (const i in this.config) &#123; this.oDiv.style[i] = this.config[i]; &#125; &#125; /* 拖拽本体 */ fnDown(ev, _this) &#123; // 判断是否为手机端 var touch; if (ev.touches) &#123; touch = ev.touches[0]; &#125; else &#123; touch = ev; &#125; this.disX = touch.clientX - this.oDiv.offsetLeft; this.disY = touch.clientY - this.oDiv.offsetTop; // pc document.onmousemove = function (ev) &#123; _this.fnMove(ev); &#125;; // 移动端 document.ontouchmove = function (ev) &#123; _this.fnMove(ev); &#125;; document.onmouseup = this.fnUp; document.ontouchend = this.fnUp; /* 阻止默认事件 */ return false; &#125; fnMove(ev) &#123; var touch; if (ev.touches) &#123; touch = ev.touches[0]; &#125; else &#123; touch = ev; &#125; this.oDiv.style.left = touch.clientX - this.disX + &apos;px&apos;; this.oDiv.style.top = touch.clientY - this.disY + &apos;px&apos;; &#125;; fnUp() &#123; document.onmousemove = null; document.ontouchmove = null; document.onmouseup = null; document.ontouchend = null; &#125; &#125; window.Drag = Drag;&#125;)(); 传送门：点击查看演示 点击查看源码","categories":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http:www.shoukailiang.cn/tags/js/"},{"name":"面向对象","slug":"面向对象","permalink":"http:www.shoukailiang.cn/tags/面向对象/"}]},{"title":"Node.js项目线上服务器部署与发布","slug":"Node-js项目线上服务器部署与发布","date":"2018-02-18","updated":"2018-02-19","comments":true,"path":"2018/02/18/Node-js项目线上服务器部署与发布/","link":"","permalink":"http:www.shoukailiang.cn/2018/02/18/Node-js项目线上服务器部署与发布/","excerpt":"","text":"Node.js项目线上服务器部署与发布 配置公钥 和密钥 可以登录服务器不需要密码看是否已经存在公钥和密钥看用户文件夹下是否存在 ctrl +d 退出用户sudo rm -f xxx 删除一个文件 12//连接ssh ubuntu@118.89.56.230 123// 先给root一个密码sudo passwd root// 然后切换到root su root 12345678910//在root下sudo adduser skl增加一个用户//然后在root下给skl sudo 权限 gpasswd -a skl sudo // sudo visudo 增加下面的skl ctrl +X保存 之后shift+Y enter 退出 可以在root 下进入skl 用户 su skl或者 sudo su skl 12//重启服务 sudo service ssh restart 12//生成公钥和私钥 ssh-keygen -t rsa -C &quot;shoukailiang@qq.com&quot; 12//配置文件 修改默认端口sudo vi /etc/ssh/sshd_config 改过端口后 连接服务器会连不上出现 : ssh: connect to host 118.89.56.230 port 22: Connection refused 这时候就要虚入输入端口号了 ssh -p 8888 ubuntu@118.89.56.230(8888是刚刚改过的端口) 123456789//更新sudo apt-get update//安装一些sudo apt-get install vim openssl build-essential libssl-dev wget curl git//找到github上的nvm https://github.com/creationix/nvm找到安装脚本 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 装完后若发现nvm 不是一个命令 在来一个命令窗口 安装好nvm 就可以安装nodejs了 nvm install v8.2.1 指定一下node版本 nvm use v8.2.2 设置一下默认 nvm alias default v8.2.1 设置成淘宝用一个nrm 包 npm –registry=http://registry.npm.taobao.org install -g nrm nrm use taobao 安装一些包 npm i pm2 webpack gulp grunt-cli -g 查看全局安装过的包 npm list -g -depth 0创建 app.js 如下 创建 vi app.js1234567var http=require(&apos;http&apos;);var server=http.createServer(function (req,res) &#123; res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/plain&apos;&#125;) res.end(&apos;Hello SKL\\n&apos;);&#125;)server.listen(8081);console.log(&apos;Server running at http://118.89.56.230:8081&apos;); 之后 node app.js就可以在浏览器中访问 127.0.0.1:8081 使用nginx 80端口 停止apache 服务 sudo service apache2 stop 12345移除Apache 2sudo update-rc.d -f apache2 removesudo apt-get remove apache2 12下载 nginx sudo apt-get install nginx 配置 cd /etc/nginx/ cd conf.d sudo vi shoukailiang-cn-8081.conf写入1234567891011121314151617181920upstream blog&#123; server 127.0.0.1:8081;&#125;# NGINX Server Instance,PORT 80server &#123; listen 80; server_name 118.89.56.230; # Proxy to the Node instance location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://blog; proxy_redirect off; &#125; &#125; 4.sudo nginx -t 测试是否成功 sudo nginx -s reload 重启 nginx 之后输入118.89.56.230 就可以看到了 把8081 的服务都导向到Nginx的80端口 让 Nginx的版本信息在浏览器的头信息中不那么明显 1234567891011cd /etc/nginxsudo vi nginx.conf去掉下面配置文件前的# 保存``` 去掉 ![](//upload-images.jianshu.io/upload_images/4362861-2d0508ad6933eb67?imageMogr2/auto-orient/strip%7CimageView2/2/w/192)然后 sudo service nginx reload### MongoDB ubuntu16.04 https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/ 命令：xxxx sudo apt-get install -y mongodb-org其中这一步速度很慢，改成阿里云的连接cd /etc/apt/sources.list.dvi mongodb-org-3.4.list (注意看安装时的版本)改成：deb [ arch=amd64,arm64 ] http://mirrors.aliyun.com/mongodb/apt/ubuntu xenial/mongodb-org/3.6 multiverse命令：// 改过镜像后要upadte一下xxxxxxxxxx123``` sudo service mongod start 之后 mongo就启动了 123若遇到无法写入。加sudo mongodb 默认跑在27017 端口上 123//修改sudo vi /etc/mongod.confport 改成了19997 文件上传12scp ./test.html shoukailiang@118.89.56.230:/home/shoukailiang/testscp -P 8888 ant-mobile-recruit-app.tar shoukailiang@118.89.56.230:/home/shoukailiang/ 打包 tar123456789-c ： 打包-v ： 显示过程-f ： 指定打包后的文件名-x : 解打包-z：压缩为.tar.gz格式 123456//压缩tar -cvf japan.tar japantar -zcvf japan.tar.gz japan//解压tar -xvf japan.tartar -zxvf japan.tar 配置可以让域名访问服务器12345678910111213141516171819202122cd /etc/nginx/conf.dsudo mv shoukailiang-cn-8081.conf www-shoukailiang-cn-3000.conf修改配置文件upstream blog&#123; server 127.0.0.1:3000; &#125; # NGINX Server Instance,PORT 80 server &#123; listen 80; server_name www.shoukailiang.cn; # Proxy to the Node instance location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://blog; proxy_redirect off; &#125; &#125; // 重启nginxsudo nginx -s reload 配一下防火墙1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253sudo apt-get update &amp;&amp; sudo apt-get upgradesudo iptables -F //先清掉所有的规则sudo vi /etc/iptables.up.rules------------------------------------------ *filter# 允许所有建立起来的连接-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# 允许所有出去的流量-A OUTPUT -j ACCEPT-A INPUT -p tcp --dport 443 -j ACCEPT-A INPUT -p tcp --dport 80 -j ACCEPT# ping-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# allow ssh port login-A INPUT -p tcp -m state --state NEW --dport 8888 -j ACCEPT# MongoDB connection-A INPUT -s 127.0.0.1 -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT# 3000端口-A INPUT -s 127.0.0.1 -p tcp --destination-port 3000 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 3000 -m state --state ESTABLISHED -j ACCEPT# 9093端口-A INPUT -s 127.0.0.1 -p tcp --destination-port 9093 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 9093 -m state --state ESTABLISHED -j ACCEPT# 记录被拒绝的请求-A INPUT -m limit --limit 5/min -j LOG --log-prefix &quot;iptables denied:&quot; --log-level 7# drop incoming sensitive connections-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --set-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60 --hitcount 150 -j DROP# reject all other inbound-A INPUT -j REJECT-A FORWARD -j REJECTCOMMIT -------------------------------------------sudo iptables-restore &lt;/etc/iptables.up.rules //载入规则sudo ufw status //查看防火墙状态sudo ufw enable //激活sudo vi /etc/network/if-up.d/iptables //让他开机自动启动·-----------------------------------#!/bin/shiptables-restore /etc/iptables.up.rulea-----------------------------------------------------sudo chmod +x /etc/network/if-up.d/iptables### 出现invalid host header的问题 12// react的话在config里面的webpackDevServer.config.js里面加一个disableHostCheck: true https配置123456789101112131415161718192021222324252627282930313233343536373839// 在腾讯云上申请证书(具体详见文档：https://cloud.tencent.com/document/product/400/4143)// 把证书下载下来上传到服务器// 修改配置文件upstream blog&#123; server 127.0.0.1:3000;&#125;# NGINX Server Instance,PORT 80server &#123; listen 80; server_name www.shoukailiang.cn; # rewrite ^(.*) https://$host$1 permanent; return 301 https://www.shoukailiang.cn$request_uri;&#125;server &#123; listen 443; server_name www.shoukailiang.cn; #填写绑定证书的域名 ssl on; ssl_certificate /home/shoukailiang/https-key/1_www.shoukailiang.cn_bundle.crt; ssl_certificate_key /home/shoukailiang/https-key/2_www.shoukailiang.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #按照这个套件配置 ssl_prefer_server_ciphers on; # if($ssl_protocol = &quot;&quot;)&#123; # rewrite ^(.*) https://$host$1 permanent; # &#125;# Proxy to the Node instancelocation / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://blog; proxy_redirect off; &#125;&#125;测试nginx 重启nginx","categories":[{"name":"运维","slug":"运维","permalink":"http:www.shoukailiang.cn/categories/运维/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/tags/前端/"},{"name":"linux","slug":"linux","permalink":"http:www.shoukailiang.cn/tags/linux/"},{"name":"node","slug":"node","permalink":"http:www.shoukailiang.cn/tags/node/"},{"name":"运维","slug":"运维","permalink":"http:www.shoukailiang.cn/tags/运维/"}]},{"title":"hexo的一些使用和配置","slug":"hexo的一些使用和配置.1","date":"2018-02-18","updated":"2018-02-19","comments":true,"path":"2018/02/18/hexo的一些使用和配置.1/","link":"","permalink":"http:www.shoukailiang.cn/2018/02/18/hexo的一些使用和配置.1/","excerpt":"","text":"github page在github 上的项目名称必须和自己用户名一样 自己的用户名是aaa项目名得是 aaa.github.io 安装hexo ,一些工具(git,node) 略过 关联 Hexo 与 GitHub Pages我们如何让本地git项目与远程的github建立联系呢？用 SSH keys 生成SSH keys输入你自己的邮箱地址1ssh-keygen -t rsa -C &quot;435072096@qq.com&quot; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，我们按回车不设置密码。 添加 SSH Key 到 GitHub打开 C:\\Users\\shouk \\ .ssh\\id_rsa.pub，此文件里面内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到 https://github.com/settings/ssh 的 new SSH key 中 测试可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：1ssh -T git@github.com 如果是下面的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到： Hi shoukailiang! You’ve successfully authenticated, but GitHub does not provide shell access. 配置Git个人信息现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。12git config --global user.name &quot;shoukailiang&quot;git config --global user.email &quot;shoukailiang@qq.com&quot; 配置 Deployment在_config.yml文件中，找到Deployment，然后按照如下修改，用户名改成你的： 需要注意的是：冒号后面记得空一格！123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:shoukailiang/shoukailiang.github.io.git branch: master 本地文件提交到 GitHub Pages12345678910111213// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d在浏览器中输入 https://shoukailiang.github.io （用户名改成你的）看到了 Hexo 与 GitHub Pages 已经成功关联了 注意1：若上面操作失败，则需要提前安装一个扩展：1npm install hexo-deployer-git --save 写文章写一篇文章,默认是以post作为模板1hexo new first(文章名) tags里面写标签1234567tags:- 前端- 后端分类categories:- 技术 生成页面1hexo new page about //以page 作为模版,会自动生成里面的index.md 搜索功能的实现 https://github.com/alexbruno/hexo-generator-json-content 部分学习自：http://www.jianshu.com/p/39562a0d8eb6","categories":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http:www.shoukailiang.cn/tags/前端/"}]}]}