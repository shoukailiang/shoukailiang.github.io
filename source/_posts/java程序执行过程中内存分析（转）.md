---
title: java程序执行过程中内存分析（转）
date: 2018-07-08 16:00:35
tags: 
  - 后端
  - java
categories:
  - 后端
---


# 内存分析

Java程序运行在JVM上，可以把JVM理解成Java程序和操作系统之间的桥梁，JVM实现了Java的平台无关性，由此可见JVM的重要性。所以在学习Java内存分配原理的时候一定要牢记这一切都是在JVM中进行的，JVM是内存分配原理的基础与前提。

###  一个完整的Java程序运行过程会涉及以下内存区域：
-  **寄存器**： JVM内部虚拟寄存器，存取速度非常快，程序不可控制。
-  **栈**： 保存局部变量的值，包括：a.用来保存基本数据类型的值；b.保存类的 **实例** ，即堆区 **对象** 的引用(指针)。也可以用来保存加载方法时的帧。
-    **堆**： 用来存放动态产生的数据，比如new出来的 **对象** 。注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次。
- **常量池**： JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的 **符号引用(1)** 。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。 **常量池存在于堆中** 。
-   **代码段**： 用来存放从硬盘上读取的源程序代码。
-   **全局数据段**： 用来存放static定义的静态成员或全局变量。分配该区时内存全部清0，结果变量的初始化为0。
### 栈(stack)：
存放：局部变量；
### 堆(heap)：
　存放new出来的对象；
### 方法区(method)：
　存放：类的信息（代码）、static变量、常量池（字符串常量）等.
栈的特点：自动分配连续的空间，后进先出；一般放置局部变量
堆的特点：不连续的空间；放置创建new出的对象；

#### 下面对如下图进行分析：
![](https://images2015.cnblogs.com/blog/690102/201601/690102-20160128142634442-1002493288.png)

![](https://images2015.cnblogs.com/blog/690102/201601/690102-20160128152115754-1747667539.png)
具体内存分析图如下所示：
![](https://images2015.cnblogs.com/blog/690102/201601/690102-20160128152521395-1714268880.png)
现对图2进行分析：

Student类：

```
public class Student {

    //静态数据
    String name;
    int id;
    int age;
    int weight;
    
    Computer computer;//每个学生有台电脑
    
    //动态的行为
    public void study(){
        System.out.println(name+"在学习");
    }
    
    public void sayHello(String sname){
        System.out.println(name + "向" +sname +"说，你好~");
    }
    
}
```
Computer类：
```
public class Computer {

    String brand;//品牌
    int cpuSpeed;//cpu
}
```
```
public class Test2 {
    public static void main(String[] args) {
        Student s1=new Student();
        s1.name="熊二";
        s1.age=18;
        
        Computer c=new Computer();
        c.brand="联想";
        c.cpuSpeed=100;
        
        s1.computer =c;
        
        //c.brand= "戴尔"; 
  System.out.println(s1.computer.brand); } }
```
具体内存分析如下：

![](https://images2015.cnblogs.com/blog/690102/201601/690102-20160128163238395-1613853502.png)

注：如果加上注释部分"c.brand= "戴尔";",s1.computer.brand最后输出的就是"戴尔".因为它们指向的是同一个地方。

# 对于java 和内存之间的注意事项
-  一个Java文件，只要有main入口方法，我们就认为这是一个Java程序，可以单独编译运行。
- 无论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。只不过普通类型的变量在栈中直接保存它所对应的值，而引用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。因此，普通类型变量只在栈区占用一块内存，而引用类型变量要在栈区和堆区各占一块内存。
- 分清什么是实例什么是对象。Class a= new Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。
- 栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。
-  以上的栈、堆、代码段、数据段等等都是相对于应用程序而言的。每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。
-  类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。


## 可以参考的文章：

[JVM内存堆布局图解分析](http://www.cnblogs.com/WJ5888/p/4374791.html)

[【java】内存分析](https://www.kancloud.cn/digest/java20151229/130204)

转载自：https://www.cnblogs.com/Qian123/p/5166351.html
